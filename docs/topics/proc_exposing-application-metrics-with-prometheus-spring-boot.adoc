[id='exposing-metrics-using-prometheus-in-a-spring-boot-application']
= Exposing application metrics using Prometheus in a {SpringBoot} application.

* Configure your application to expose metrics.
* Collect and view the data using Prometheus.

Prometheus actively connects to a monitored application to collect data; the application does not actively send metrics to a server.

.Prerequisites

* Prometheus configured to collect metrics from the application:
+
--
. Download and extract the link:https://prometheus.io/download/[archive^] with the latest Prometheus release:
+
[source,bash,options="nowrap"]
----
$ wget https://github.com/prometheus/prometheus/releases/download/v2.4.3/prometheus-2.4.3.linux-amd64.tar.gz
$ tar -xvf  prometheus-2.4.3.linux-amd64.tar.gz
----

. Navigate to the directory with Prometheus:
+
[source,bash,options="nowrap"]
----
$ cd  prometheus-2.4.3.linux-amd64
----

. Append the following snippet to the `prometheus.yml` file to specify the port where your application exposes the metrics endpoint.
+
The `scrape_interval` setting is optional and sets Prometheus to collect metrics every 5 seconds.
+
[source,yaml,options="nowrap"]
----
  - job_name: 'spring-actuator'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    static_configs:
    - targets: ['localhost:8080']
----
+
If you have the `spring-boot-starter-actuator` dependency in your `pom.xml` file, {SpringBoot}-based applications expose metrics at the `/actuator/prometheus` endpoint by default.
You can change the endpoint at which your application exposes the metrics by setting the `endpoints.prometheus.id` property to a different path, for example: `endpoints.prometheus.id=micrometheus`.
+
The endpoint is secured by default.
To ensure that metrics collection works in your application, you must:
* include authentication in your Prometheus metrics collection endpoint, or
* make the endpoint unsecured by setting a property, such as `management.security.enabled=false`
--

* The Prometheus server started on `localhost`:
+
--
Start Prometheus and wait until the `Server is ready to receive web requests` message is displayed in the console.

[source,bash,options="nowrap"]
----
$ ./prometheus
----
--

.Procedure

. Include the `spring-boot-starter-actuator`, `micrometer-registry-prometheus` and `micrometer-spring-legacy` dependencies in your `pom.xml`.
The `micrometer-spring-legacy` dependency is required to provide Micrometer support for {SpringBoot} 1.5 applications.

.pom.xml
[source,xml]
----
<dependencies>
  ...
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
  </dependency>
  <dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-spring-legacy</artifactId>
  </dependency>
  <dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
  </dependency>
  ...
</dependencies>
----
+
`spring-boot-starter-actuator` automatically records a `Timer` metric on each endpoint exposed your application.
The default name for the `Timer` metric is set to `http.server.requests`.
You can set a custom name for the metric:
+
[source,properties,options="nowrap"]
----
# default is `http.server.requests`
management.metrics.web.server.requests-metric-name=custom.timer.metric.name
----
+
The `Timer` metric contains a set of dimensions recorded for every request.
By default, these dimensions are:
+
// maybe not required for the procedure?
--
`method`:: the HTTP method used when calling the endpoint (for example, `GET` or `PUT`)

`status`:: the numeric HTTP status code returned in response to the request (for example, `200`, `201`, `500`)

`uri`:: the URI template prior to variable substitution (for example, `/api/person/{id}`)

`exception`:: if an exception is thrown by your application upon receiving a request, this dimension records the simple name of the exception class
--

. Alternatively, to only record the `Timer` for specific endpoints:
+
--
. Disable the `auto-time-requests` property in the `spring-boot-starter-actuator` configuration in your application.
+
[source,properties,options="nowrap"]
----
# true by default
management.metrics.web.server.auto-time-requests=false
----

. Annotate methods or classes with the metrics annotations, for example:
+
[source,java,options="nowrap"]
----
//TBD
----
--
//Here, the `@Counted(monotonic = true)` annotation is used to keep track of how many times this method was invoked.
//The `@Timed` annotation is used to keep track of how long the invocations took.

//In this example, a JAX-RS resource method was annotated directly, but you can annotate any CDI bean in your application as well.

. Launch your application:
+
[source,bash,opts="nowrap"]
----
$ mvn spring-boot:run
----

. Invoke the traced endpoint several times:
+
[source,bash,opts="nowrap"]
----
$ curl http://localhost:8080/
Hello from counted and timed endpoint
----

. Wait at least 15 seconds for the collection to happen, and see the metrics in Prometheus UI:
+
--
. Open the Prometheus UI at link:http://localhost:9090/[http://localhost:9090/^] and type `hello` into the _Expression_ box.
. From the suggestions, select for example `application:hello_count` and click _Execute_.
. In the table that is displayed, you can see how many times the resource method was invoked.
. Alternatively, select `application:hello_time_mean_seconds` to see the mean time of all the invocations.

Note that all metrics you created are prefixed with `application:`.
There are other metrics, automatically exposed by {SpringBoot}.
Those metrics are prefixed with `base:` and `vendor:` and expose information about the JVM in which the application runs.
--

.Additional resources

* For additional types of metrics, see the link:https://github.com/eclipse/microprofile-metrics[MicroProfile Metrics documentation^].
